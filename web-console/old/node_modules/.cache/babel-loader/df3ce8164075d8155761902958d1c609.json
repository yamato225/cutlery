{"ast":null,"code":"'use strict';\n\nvar tls = require('tls');\n\nfunction buildBuilder(mqttClient, opts) {\n  var connection;\n  opts.port = opts.port || 8883;\n  opts.host = opts.hostname || opts.host || 'localhost';\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n  delete opts.path;\n  connection = tls.connect(opts);\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'));\n    } else {\n      connection.removeListener('error', handleTLSerrors);\n    }\n  });\n\n  function handleTLSerrors(err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err);\n    } // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n\n\n    connection.end();\n  }\n\n  connection.on('error', handleTLSerrors);\n  return connection;\n}\n\nmodule.exports = buildBuilder;","map":{"version":3,"sources":["/react/cutlery/web-console/node_modules/mqtt/lib/connect/tls.js"],"names":["tls","require","buildBuilder","mqttClient","opts","connection","port","host","hostname","rejectUnauthorized","path","connect","on","authorized","emit","Error","removeListener","handleTLSerrors","err","end","module","exports"],"mappings":"AAAA;;AACA,IAAIA,GAAG,GAAGC,OAAO,CAAC,KAAD,CAAjB;;AAEA,SAASC,YAAT,CAAuBC,UAAvB,EAAmCC,IAAnC,EAAyC;AACvC,MAAIC,UAAJ;AACAD,EAAAA,IAAI,CAACE,IAAL,GAAYF,IAAI,CAACE,IAAL,IAAa,IAAzB;AACAF,EAAAA,IAAI,CAACG,IAAL,GAAYH,IAAI,CAACI,QAAL,IAAiBJ,IAAI,CAACG,IAAtB,IAA8B,WAA1C;AAEAH,EAAAA,IAAI,CAACK,kBAAL,GAA0BL,IAAI,CAACK,kBAAL,KAA4B,KAAtD;AAEA,SAAOL,IAAI,CAACM,IAAZ;AAEAL,EAAAA,UAAU,GAAGL,GAAG,CAACW,OAAJ,CAAYP,IAAZ,CAAb;AACA;;AACAC,EAAAA,UAAU,CAACO,EAAX,CAAc,eAAd,EAA+B,YAAY;AACzC,QAAIR,IAAI,CAACK,kBAAL,IAA2B,CAACJ,UAAU,CAACQ,UAA3C,EAAuD;AACrDR,MAAAA,UAAU,CAACS,IAAX,CAAgB,OAAhB,EAAyB,IAAIC,KAAJ,CAAU,oBAAV,CAAzB;AACD,KAFD,MAEO;AACLV,MAAAA,UAAU,CAACW,cAAX,CAA0B,OAA1B,EAAmCC,eAAnC;AACD;AACF,GAND;;AAQA,WAASA,eAAT,CAA0BC,GAA1B,EAA+B;AAC7B;AACA,QAAId,IAAI,CAACK,kBAAT,EAA6B;AAC3BN,MAAAA,UAAU,CAACW,IAAX,CAAgB,OAAhB,EAAyBI,GAAzB;AACD,KAJ4B,CAM7B;AACA;AACA;AACA;AACA;;;AACAb,IAAAA,UAAU,CAACc,GAAX;AACD;;AAEDd,EAAAA,UAAU,CAACO,EAAX,CAAc,OAAd,EAAuBK,eAAvB;AACA,SAAOZ,UAAP;AACD;;AAEDe,MAAM,CAACC,OAAP,GAAiBnB,YAAjB","sourcesContent":["'use strict'\nvar tls = require('tls')\n\nfunction buildBuilder (mqttClient, opts) {\n  var connection\n  opts.port = opts.port || 8883\n  opts.host = opts.hostname || opts.host || 'localhost'\n\n  opts.rejectUnauthorized = opts.rejectUnauthorized !== false\n\n  delete opts.path\n\n  connection = tls.connect(opts)\n  /* eslint no-use-before-define: [2, \"nofunc\"] */\n  connection.on('secureConnect', function () {\n    if (opts.rejectUnauthorized && !connection.authorized) {\n      connection.emit('error', new Error('TLS not authorized'))\n    } else {\n      connection.removeListener('error', handleTLSerrors)\n    }\n  })\n\n  function handleTLSerrors (err) {\n    // How can I get verify this error is a tls error?\n    if (opts.rejectUnauthorized) {\n      mqttClient.emit('error', err)\n    }\n\n    // close this connection to match the behaviour of net\n    // otherwise all we get is an error from the connection\n    // and close event doesn't fire. This is a work around\n    // to enable the reconnect code to work the same as with\n    // net.createConnection\n    connection.end()\n  }\n\n  connection.on('error', handleTLSerrors)\n  return connection\n}\n\nmodule.exports = buildBuilder\n"]},"metadata":{},"sourceType":"script"}