{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar events = require('events');\n\nvar Store = require('./store');\n\nvar mqttPacket = require('mqtt-packet');\n\nvar Writable = require('readable-stream').Writable;\n\nvar inherits = require('inherits');\n\nvar reInterval = require('reinterval');\n\nvar validations = require('./validations');\n\nvar xtend = require('xtend');\n\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback);\n};\n\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nvar errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\n\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\n\nfunction sendPacket(client, packet, cb) {\n  client.emit('packetsend', packet);\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n\n  if (!result && cb) {\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    cb();\n  }\n}\n\nfunction flush(queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction flushVolatile(queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  client.outgoingStore.put(packet, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\n\nfunction nop() {}\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\n\n\nfunction MqttClient(streamBuilder, options) {\n  var k;\n  var that = this;\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n\n  this.options = options || {}; // Defaults\n\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder; // Inflight message storages\n\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero; // map of subscribed topics to support reconnection\n\n  this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n  this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n  this.pingTimer = null; // Is the client connected?\n\n  this.connected = false; // Are we disconnecting?\n\n  this.disconnecting = false; // Packet queue\n\n  this.queue = []; // connack timer\n\n  this.connackTimer = null; // Reconnect timer\n\n  this.reconnectTimer = null; // Is processing store?\n\n  this._storeProcessing = false; // Packet Ids are put into the store during store processing\n\n  this._packetIdsDuringStoreProcessing = {};\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535)); // Inflight callbacks\n\n  this.outgoing = {}; // True if connection is first time.\n\n  this._firstConnection = true; // Mark disconnected on stream close\n\n  this.on('close', function () {\n    this.connected = false;\n    clearTimeout(this.connackTimer);\n  }); // Send queued packets\n\n  this.on('connect', function () {\n    var queue = this.queue;\n\n    function deliver() {\n      var entry = queue.shift();\n      var packet = null;\n\n      if (!entry) {\n        return;\n      }\n\n      packet = entry.packet;\n\n      that._sendPacket(packet, function (err) {\n        if (entry.cb) {\n          entry.cb(err);\n        }\n\n        deliver();\n      });\n    }\n\n    deliver();\n  }); // Clear ping timer\n\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n  }); // Setup reconnect timer on disconnect\n\n  this.on('close', this._setupReconnect);\n  events.EventEmitter.call(this);\n\n  this._setupStream();\n}\n\ninherits(MqttClient, events.EventEmitter);\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\n\nMqttClient.prototype._setupStream = function () {\n  var connectPacket;\n  var that = this;\n  var writable = new Writable();\n  var parser = mqttPacket.parser(this.options);\n  var completeParse = null;\n  var packets = [];\n\n  this._clearReconnect();\n\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    packets.push(packet);\n  });\n\n  function nextTickWork() {\n    if (packets.length) {\n      process.nextTick(work);\n    } else {\n      var done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n\n  function work() {\n    var packet = packets.shift();\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      var done = completeParse;\n      completeParse = null;\n      if (done) done();\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    parser.parse(buf);\n    work();\n  };\n\n  this.stream.pipe(writable); // Suppress connection errors\n\n  this.stream.on('error', nop); // Echo stream close\n\n  this.stream.on('close', function () {\n    flushVolatile(that.outgoing);\n    that.emit('close');\n  }); // Send a connect packet\n\n  connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect'; // avoid message queue\n\n  sendPacket(this, connectPacket); // Echo connection errors\n\n  parser.on('error', this.emit.bind(this, 'error')); // auth\n\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      this.emit('error', new Error('Packet has no Authentication Method'));\n      return this;\n    }\n\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      var authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  } // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  var options = this.options;\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n\n  this.emit('packetreceive', packet);\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n\n      break;\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n\n      done();\n      break;\n\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n\n      break;\n\n    case 'connack':\n      this._handleConnack(packet);\n\n      done();\n      break;\n\n    case 'pingresp':\n      this._handlePingresp(packet);\n\n      done();\n      break;\n\n    case 'disconnect':\n      this._handleDisconnect(packet);\n\n      done();\n      break;\n\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n\n  return this.disconnecting;\n};\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\n\n\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet;\n  var options = this.options; // .publish(topic, payload, cb);\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  } // default opts\n\n\n  var defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  };\n\n  if (options.protocolVersion === 5) {\n    packet.properties = opts.properties;\n\n    if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum || !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n      /*\n      if we are don`t setup topic alias or\n      topic alias maximum less than topic alias or\n      server don`t give topic alias maximum,\n      we are removing topic alias from packet\n      */\n      delete packet.properties.topicAlias;\n    }\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = {\n        volatile: false,\n        cb: callback || nop\n      };\n\n      if (this._storeProcessing) {\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n\n        this._storePacket(packet, undefined, opts.cbStorePut);\n      } else {\n        this._sendPacket(packet, undefined, opts.cbStorePut);\n      }\n\n      break;\n\n    default:\n      if (this._storeProcessing) {\n        this._storePacket(packet, callback, opts.cbStorePut);\n      } else {\n        this._sendPacket(packet, callback, opts.cbStorePut);\n      }\n\n      break;\n  }\n\n  return this;\n};\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.subscribe = function () {\n  var packet;\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  var subs = [];\n  var obj = args.shift();\n  var resubscribe = obj.resubscribe;\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n  var invalidTopic;\n  var that = this;\n  var version = this.options.protocolVersion;\n  delete obj.resubscribe;\n\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  invalidTopic = validations.validateTopics(obj);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  var defaultOpts = {\n    qos: 0\n  };\n\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n\n  opts = xtend(defaultOpts, opts);\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (!that._resubscribeTopics.hasOwnProperty(topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        var currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      if (!that._resubscribeTopics.hasOwnProperty(k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        var currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        subs.push(currentOpts);\n      }\n    });\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  };\n\n  if (opts.properties) {\n    packet.properties = opts.properties;\n  }\n\n  if (!subs.length) {\n    callback(null, []);\n    return;\n  } // subscriptions to resubscribe to in case of disconnect\n\n\n  if (this.options.resubscribe) {\n    var topics = [];\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        var topic = {\n          qos: sub.qos\n        };\n\n        if (version === 5) {\n          topic.nl = sub.nl || false;\n          topic.rap = sub.rap || false;\n          topic.rh = sub.rh || 0;\n          topic.properties = sub.properties;\n        }\n\n        that._resubscribeTopics[sub.topic] = topic;\n        topics.push(sub.topic);\n      }\n    });\n    that.messageIdToTopic[packet.messageId] = topics;\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: function cb(err, packet) {\n      if (!err) {\n        var granted = packet.granted;\n\n        for (var i = 0; i < granted.length; i += 1) {\n          subs[i].qos = granted[i];\n        }\n      }\n\n      callback(err, subs);\n    }\n  };\n\n  this._sendPacket(packet);\n\n  return this;\n};\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.unsubscribe = function () {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  };\n  var that = this;\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  var topic = args.shift();\n  var callback = args.pop() || nop;\n  var opts = args.pop();\n\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic];\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic;\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic];\n    });\n  }\n\n  if (typeof opts === 'object' && opts.properties) {\n    packet.properties = opts.properties;\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: callback\n  };\n\n  this._sendPacket(packet);\n\n  return this;\n};\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\n\n\nMqttClient.prototype.end = function () {\n  var that = this;\n  var force = arguments[0];\n  var opts = arguments[1];\n  var cb = arguments[2];\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n\n  cb = cb || nop;\n\n  function closeStores() {\n    that.disconnected = true;\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        if (cb) {\n          cb.apply(null, arguments);\n        }\n\n        that.emit('end');\n      });\n    });\n\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores), opts);\n  }\n\n  if (this.disconnecting) {\n    return this;\n  }\n\n  this._clearReconnect();\n\n  this.disconnecting = true;\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    finish();\n  }\n\n  return this;\n};\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\n\n\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null;\n  delete this.outgoing[mid];\n  this.outgoingStore.del({\n    messageId: mid\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\n\n\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this;\n\n  var f = function f() {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n\n    that._reconnect();\n  };\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n\n  return this;\n};\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\n\n\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect');\n\n  this._setupStream();\n};\n/**\n * _setupReconnect - setup reconnect timer\n */\n\n\nMqttClient.prototype._setupReconnect = function () {\n  var that = this;\n\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      this.emit('offline');\n      this.reconnecting = true;\n    }\n\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  }\n};\n/**\n * _clearReconnect - clear the reconnect timer\n */\n\n\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\n\n\nMqttClient.prototype._cleanUp = function (forced, done) {\n  var opts = arguments[2];\n\n  if (done) {\n    this.stream.on('close', done);\n  }\n\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n\n    this.stream.destroy();\n  } else {\n    var packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect();\n\n    this._setupReconnect();\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n\n  if (done && !this.connected) {\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\n\n\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  cbStorePut = cbStorePut || nop;\n\n  if (!this.connected) {\n    this._storePacket(packet, cb, cbStorePut);\n\n    return;\n  } // When sending a packet, reschedule the ping timer\n\n\n  this._shiftPingInterval();\n\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n\n    case 0:\n    /* falls through */\n\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n};\n/**\n * _storePacket - queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\n\n\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  cbStorePut = cbStorePut || nop;\n\n  if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n    this.queue.push({\n      packet: packet,\n      cb: cb\n    });\n  } else if (packet.qos > 0) {\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n    this.outgoingStore.put(packet, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\n\n\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this;\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\n\n\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\n\n\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false;\n\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true);\n  }\n};\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\n\n\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var options = this.options;\n  var version = options.protocolVersion;\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n    }\n\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n\n      this._shiftPingInterval();\n    }\n\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false;\n\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\n\n\nMqttClient.prototype._handlePublish = function (packet, done) {\n  done = typeof done !== 'undefined' ? done : nop;\n  var topic = packet.topic.toString();\n  var message = packet.payload;\n  var qos = packet.qos;\n  var mid = packet.messageId;\n  var that = this;\n  var options = this.options;\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: mid,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: mid\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: mid,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break;\n  }\n};\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\n\n\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId;\n  var type = packet.cmd;\n  var response = null;\n  var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null;\n  var that = this;\n  var err;\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return;\n  } // Process\n\n\n  switch (type) {\n    case 'pubcomp': // same thing as puback for QoS 2\n\n    case 'puback':\n      var pubackRC = packet.reasonCode; // Callback - we're done\n\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC]);\n        err.code = pubackRC;\n        cb(err, packet);\n      }\n\n      delete this.outgoing[mid];\n      this.outgoingStore.del(packet, cb);\n      break;\n\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      };\n      var pubrecRC = packet.reasonCode;\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC]);\n        err.code = pubrecRC;\n        cb(err, packet);\n      } else {\n        this._sendPacket(response);\n      }\n\n      break;\n\n    case 'suback':\n      delete this.outgoing[mid];\n\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          var topics = this.messageIdToTopic[mid];\n\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic];\n            });\n          }\n        }\n      }\n\n      cb(null, packet);\n      break;\n\n    case 'unsuback':\n      delete this.outgoing[mid];\n      cb(null);\n      break;\n\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  var mid = packet.messageId;\n  var that = this;\n  var comp = {\n    cmd: 'pubcomp',\n    messageId: mid\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        that.incomingStore.del(pub, nop);\n\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n/**\n * _nextId\n * @return unsigned int\n */\n\n\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++; // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n\n  if (this.nextId === 65536) {\n    this.nextId = 1;\n  }\n\n  return id;\n};\n/**\n * getLastMessageId\n * @return unsigned int\n */\n\n\nMqttClient.prototype.getLastMessageId = function () {\n  return this.nextId === 1 ? 65535 : this.nextId - 1;\n};\n/**\n * _resubscribe\n * @api private\n */\n\n\nMqttClient.prototype._resubscribe = function (connack) {\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          var resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n\n  this._firstConnection = false;\n};\n/**\n * _onConnect\n *\n * @api private\n */\n\n\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n\n  var that = this;\n\n  this._setupPingTimer();\n\n  this._resubscribe(packet);\n\n  this.connected = true;\n\n  function startStreamProcess() {\n    var outStore = that.outgoingStore.createStream();\n\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n      clearStoreProcessing();\n    }\n\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n\n      that._storeProcessing = true;\n      var packet = outStore.read(1);\n\n      var _cb;\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      } // Skip already processed store packets\n\n\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      } // Avoid unnecessary stream read operations when disconnected\n\n\n      if (!that.disconnecting && !that.reconnectTimer) {\n        _cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function cb(err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (_cb) {\n              _cb(err, status);\n            }\n\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n\n        that._sendPacket(packet);\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n\n    outStore.on('end', function () {\n      var allProcessed = true;\n\n      for (var id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  } // start flowing\n\n\n  startStreamProcess();\n};\n\nmodule.exports = MqttClient;","map":{"version":3,"sources":["/react/cutlery/web-console/node_modules/mqtt/lib/client.js"],"names":["events","require","Store","mqttPacket","Writable","inherits","reInterval","validations","xtend","setImmediate","global","callback","process","nextTick","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","errors","defaultId","Math","random","toString","substr","sendPacket","client","packet","cb","emit","result","writeToStream","stream","options","once","flush","queue","Object","keys","forEach","messageId","Error","flushVolatile","volatile","storeAndSend","cbStorePut","outgoingStore","put","storedPacket","err","nop","MqttClient","streamBuilder","k","that","clientId","customHandleAcks","arguments","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","nextId","max","floor","outgoing","_firstConnection","on","clearTimeout","deliver","entry","shift","_sendPacket","clear","_setupReconnect","EventEmitter","call","_setupStream","prototype","connectPacket","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","length","work","done","_handlePacket","_write","buf","enc","parse","pipe","create","cmd","bind","properties","authenticationMethod","authenticationData","authPacket","reasonCode","setMaxListeners","setTimeout","_cleanUp","maximumPacketSize","end","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","topic","message","opts","defaultOpts","qos","retain","dup","payload","_nextId","topicAlias","topicAliasMaximum","_storePacket","subscribe","args","Array","i","subs","obj","pop","invalidTopic","version","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscriptions","topics","sub","granted","unsubscribe","unsubscriptions","force","closeStores","disconnected","close","apply","_deferredReconnect","finish","removeOutgoingMessage","mid","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","code","validReasonCodes","error","indexOf","handleMessage","type","response","pubackRC","pubrecRC","grantedI","comp","get","pub","id","getLastMessageId","_resubscribe","connack","_resubscribeTopicsKeys","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","storeDeliver","read","status","allProcessed","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\nvar events = require('events')\nvar Store = require('./store')\nvar mqttPacket = require('mqtt-packet')\nvar Writable = require('readable-stream').Writable\nvar inherits = require('inherits')\nvar reInterval = require('reinterval')\nvar validations = require('./validations')\nvar xtend = require('xtend')\nvar setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  process.nextTick(callback)\n}\nvar defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\nvar errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction sendPacket (client, packet, cb) {\n  client.emit('packetsend', packet)\n\n  var result = mqttPacket.writeToStream(packet, client.stream, client.options)\n\n  if (!result && cb) {\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction flushVolatile (queue) {\n  if (queue) {\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb, cbStorePut) {\n  client.outgoingStore.put(packet, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    cbStorePut()\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop () {}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  var k\n  var that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\n\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\n\n  this.streamBuilder = streamBuilder\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store()\n  this.incomingStore = options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // Is processing store?\n  this._storeProcessing = false\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {}\n  /**\n   * MessageIDs starting with 1\n   * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n   */\n  this.nextId = Math.max(1, Math.floor(Math.random() * 65535))\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // True if connection is first time.\n  this._firstConnection = true\n\n  // Mark disconnected on stream close\n  this.on('close', function () {\n    this.connected = false\n    clearTimeout(this.connackTimer)\n  })\n\n  // Send queued packets\n  this.on('connect', function () {\n    var queue = this.queue\n\n    function deliver () {\n      var entry = queue.shift()\n      var packet = null\n\n      if (!entry) {\n        return\n      }\n\n      packet = entry.packet\n\n      that._sendPacket(\n        packet,\n        function (err) {\n          if (entry.cb) {\n            entry.cb(err)\n          }\n          deliver()\n        }\n      )\n    }\n\n    deliver()\n  })\n\n  // Clear ping timer\n  this.on('close', function () {\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n  })\n\n  // Setup reconnect timer on disconnect\n  this.on('close', this._setupReconnect)\n\n  events.EventEmitter.call(this)\n\n  this._setupStream()\n}\ninherits(MqttClient, events.EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  var connectPacket\n  var that = this\n  var writable = new Writable()\n  var parser = mqttPacket.parser(this.options)\n  var completeParse = null\n  var packets = []\n\n  this._clearReconnect()\n\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    if (packets.length) {\n      process.nextTick(work)\n    } else {\n      var done = completeParse\n      completeParse = null\n      done()\n    }\n  }\n\n  function work () {\n    var packet = packets.shift()\n\n    if (packet) {\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      var done = completeParse\n      completeParse = null\n      if (done) done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    parser.parse(buf)\n    work()\n  }\n\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', nop)\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    flushVolatile(that.outgoing)\n    that.emit('close')\n  })\n\n  // Send a connect packet\n  connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      this.emit('error', new Error('Packet has no Authentication Method'))\n      return this\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      var authPacket = xtend({cmd: 'auth', reasonCode: 0}, this.options.authPacket)\n      sendPacket(this, authPacket)\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  var options = this.options\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\n    this.end({reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' }})\n    return this\n  }\n\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    case 'disconnect':\n      this._handleDisconnect(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  var packet\n  var options = this.options\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  var defaultOpts = {qos: 0, retain: false, dup: false}\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  packet = {\n    cmd: 'publish',\n    topic: topic,\n    payload: message,\n    qos: opts.qos,\n    retain: opts.retain,\n    messageId: this._nextId(),\n    dup: opts.dup\n  }\n\n  if (options.protocolVersion === 5) {\n    packet.properties = opts.properties\n    if ((!options.properties && packet.properties && packet.properties.topicAlias) || ((opts.properties && options.properties) &&\n      ((opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum) ||\n        (!options.properties.topicAliasMaximum && opts.properties.topicAlias)))) {\n      /*\n      if we are don`t setup topic alias or\n      topic alias maximum less than topic alias or\n      server don`t give topic alias maximum,\n      we are removing topic alias from packet\n      */\n      delete packet.properties.topicAlias\n    }\n  }\n\n  switch (opts.qos) {\n    case 1:\n    case 2:\n      // Add to callbacks\n      this.outgoing[packet.messageId] = {\n        volatile: false,\n        cb: callback || nop\n      }\n      if (this._storeProcessing) {\n        this._packetIdsDuringStoreProcessing[packet.messageId] = false\n        this._storePacket(packet, undefined, opts.cbStorePut)\n      } else {\n        this._sendPacket(packet, undefined, opts.cbStorePut)\n      }\n      break\n    default:\n      if (this._storeProcessing) {\n        this._storePacket(packet, callback, opts.cbStorePut)\n      } else {\n        this._sendPacket(packet, callback, opts.cbStorePut)\n      }\n      break\n  }\n\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  var packet\n  var args = new Array(arguments.length)\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  var subs = []\n  var obj = args.shift()\n  var resubscribe = obj.resubscribe\n  var callback = args.pop() || nop\n  var opts = args.pop()\n  var invalidTopic\n  var that = this\n  var version = this.options.protocolVersion\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  var defaultOpts = {\n    qos: 0\n  }\n  if (version === 5) {\n    defaultOpts.nl = false\n    defaultOpts.rap = false\n    defaultOpts.rh = 0\n  }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      if (!that._resubscribeTopics.hasOwnProperty(topic) ||\n        that._resubscribeTopics[topic].qos < opts.qos ||\n          resubscribe) {\n        var currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        }\n        if (version === 5) {\n          currentOpts.nl = opts.nl\n          currentOpts.rap = opts.rap\n          currentOpts.rh = opts.rh\n          currentOpts.properties = opts.properties\n        }\n        subs.push(currentOpts)\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        if (!that._resubscribeTopics.hasOwnProperty(k) ||\n          that._resubscribeTopics[k].qos < obj[k].qos ||\n            resubscribe) {\n          var currentOpts = {\n            topic: k,\n            qos: obj[k].qos\n          }\n          if (version === 5) {\n            currentOpts.nl = obj[k].nl\n            currentOpts.rap = obj[k].rap\n            currentOpts.rh = obj[k].rh\n            currentOpts.properties = opts.properties\n          }\n          subs.push(currentOpts)\n        }\n      })\n  }\n\n  packet = {\n    cmd: 'subscribe',\n    subscriptions: subs,\n    qos: 1,\n    retain: false,\n    dup: false,\n    messageId: this._nextId()\n  }\n\n  if (opts.properties) {\n    packet.properties = opts.properties\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return\n  }\n\n  // subscriptions to resubscribe to in case of disconnect\n  if (this.options.resubscribe) {\n    var topics = []\n    subs.forEach(function (sub) {\n      if (that.options.reconnectPeriod > 0) {\n        var topic = { qos: sub.qos }\n        if (version === 5) {\n          topic.nl = sub.nl || false\n          topic.rap = sub.rap || false\n          topic.rh = sub.rh || 0\n          topic.properties = sub.properties\n        }\n        that._resubscribeTopics[sub.topic] = topic\n        topics.push(sub.topic)\n      }\n    })\n    that.messageIdToTopic[packet.messageId] = topics\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: function (err, packet) {\n      if (!err) {\n        var granted = packet.granted\n        for (var i = 0; i < granted.length; i += 1) {\n          subs[i].qos = granted[i]\n        }\n      }\n\n      callback(err, subs)\n    }\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  var packet = {\n    cmd: 'unsubscribe',\n    qos: 1,\n    messageId: this._nextId()\n  }\n  var that = this\n  var args = new Array(arguments.length)\n  for (var i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  var topic = args.shift()\n  var callback = args.pop() || nop\n  var opts = args.pop()\n\n  if (typeof topic === 'string') {\n    topic = [topic]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  if (typeof topic === 'string') {\n    packet.unsubscriptions = [topic]\n  } else if (typeof topic === 'object' && topic.length) {\n    packet.unsubscriptions = topic\n  }\n\n  if (this.options.resubscribe) {\n    packet.unsubscriptions.forEach(function (topic) {\n      delete that._resubscribeTopics[topic]\n    })\n  }\n\n  if (typeof opts === 'object' && opts.properties) {\n    packet.properties = opts.properties\n  }\n\n  this.outgoing[packet.messageId] = {\n    volatile: true,\n    cb: callback\n  }\n\n  this._sendPacket(packet)\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function () {\n  var that = this\n\n  var force = arguments[0]\n  var opts = arguments[1]\n  var cb = arguments[2]\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop\n    opts = force\n    force = false\n    if (typeof opts !== 'object') {\n      cb = opts\n      opts = null\n      if (typeof cb !== 'function') {\n        cb = nop\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts\n    opts = null\n  }\n\n  cb = cb || nop\n\n  function closeStores () {\n    that.disconnected = true\n    that.incomingStore.close(function () {\n      that.outgoingStore.close(function () {\n        if (cb) {\n          cb.apply(null, arguments)\n        }\n        that.emit('end')\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    that._cleanUp(force, setImmediate.bind(null, closeStores), opts)\n  }\n\n  if (this.disconnecting) {\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} mid - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastMessageId());\n */\nMqttClient.prototype.removeOutgoingMessage = function (mid) {\n  var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null\n  delete this.outgoing[mid]\n  this.outgoingStore.del({messageId: mid}, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  var that = this\n  var f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  this.emit('reconnect')\n  this._setupStream()\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  var that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      this.emit('offline')\n      this.reconnecting = true\n    }\n    that.reconnectTimer = setInterval(function () {\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  var opts = arguments[2]\n  if (done) {\n    this.stream.on('close', done)\n  }\n\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    this.stream.destroy()\n  } else {\n    var packet = xtend({ cmd: 'disconnect' }, opts)\n    this._sendPacket(\n      packet,\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  cbStorePut = cbStorePut || nop\n\n  if (!this.connected) {\n    this._storePacket(packet, cb, cbStorePut)\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n}\n\n/**\n * _storePacket - queue a packet\n * @param {String} type - packet type (see `protocol`)\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  cbStorePut = cbStorePut || nop\n\n  if (((packet.qos || 0) === 0 && this.queueQoSZero) || packet.cmd !== 'publish') {\n    this.queue.push({ packet: packet, cb: cb })\n  } else if (packet.qos > 0) {\n    cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null\n    this.outgoingStore.put(packet, function (err) {\n      if (err) {\n        return cb && cb(err)\n      }\n      cbStorePut()\n    })\n  } else if (cb) {\n    cb(new Error('No connection to broker'))\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  var that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  if (this.pingResp) {\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleConnack = function (packet) {\n  var options = this.options\n  var version = options.protocolVersion\n  var rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  clearTimeout(this.connackTimer)\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive\n      this._shiftPingInterval()\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this._onConnect(packet)\n  } else if (rc > 0) {\n    var err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: mid\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  done = typeof done !== 'undefined' ? done : nop\n  var topic = packet.topic.toString()\n  var message = packet.payload\n  var qos = packet.qos\n  var mid = packet.messageId\n  var that = this\n  var options = this.options\n  var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\n\n  switch (qos) {\n    case 2: {\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\n        if (code) {\n          that._sendPacket({cmd: 'pubrec', messageId: mid, reasonCode: code}, done)\n        } else {\n          that.incomingStore.put(packet, function () {\n            that._sendPacket({cmd: 'pubrec', messageId: mid}, done)\n          })\n        }\n      })\n      break\n    }\n    case 1: {\n      // emit the message event\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\n        if (!code) { that.emit('message', topic, message, packet) }\n        that.handleMessage(packet, function (err) {\n          if (err) {\n            return done && done(err)\n          }\n          that._sendPacket({cmd: 'puback', messageId: mid, reasonCode: code}, done)\n        })\n      })\n      break\n    }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  var mid = packet.messageId\n  var type = packet.cmd\n  var response = null\n  var cb = this.outgoing[mid] ? this.outgoing[mid].cb : null\n  var that = this\n  var err\n\n  if (!cb) {\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback':\n      var pubackRC = packet.reasonCode\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC])\n        err.code = pubackRC\n        cb(err, packet)\n      }\n      delete this.outgoing[mid]\n      this.outgoingStore.del(packet, cb)\n      break\n    case 'pubrec':\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: mid\n      }\n      var pubrecRC = packet.reasonCode\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC])\n        err.code = pubrecRC\n        cb(err, packet)\n      } else {\n        this._sendPacket(response)\n      }\n      break\n    case 'suback':\n      delete this.outgoing[mid]\n      for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          var topics = this.messageIdToTopic[mid]\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic]\n            })\n          }\n        }\n      }\n      cb(null, packet)\n      break\n    case 'unsuback':\n      delete this.outgoing[mid]\n      cb(null)\n      break\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  callback = typeof callback !== 'undefined' ? callback : nop\n  var mid = packet.messageId\n  var that = this\n\n  var comp = {cmd: 'pubcomp', messageId: mid}\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.incomingStore.del(pub, nop)\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet)\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  // id becomes current state of this.nextId and increments afterwards\n  var id = this.nextId++\n  // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n  if (this.nextId === 65536) {\n    this.nextId = 1\n  }\n  return id\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return (this.nextId === 1) ? 65535 : (this.nextId - 1)\n}\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function (connack) {\n  var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n  if (!this._firstConnection &&\n      (this.options.clean || (this.options.protocolVersion === 5 && !connack.sessionPresent)) &&\n      _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          var resubscribeTopic = {}\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\n          resubscribeTopic.resubscribe = true\n          this.subscribe(resubscribeTopic, {properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties})\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      }\n    } else {\n      this._resubscribeTopics = {}\n    }\n  }\n\n  this._firstConnection = false\n}\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet)\n    return\n  }\n\n  var that = this\n\n  this._setupPingTimer()\n  this._resubscribe(packet)\n\n  this.connected = true\n\n  function startStreamProcess () {\n    var outStore = that.outgoingStore.createStream()\n\n    function clearStoreProcessing () {\n      that._storeProcessing = false\n      that._packetIdsDuringStoreProcessing = {}\n    }\n\n    that.once('close', remove)\n    outStore.on('error', function (err) {\n      clearStoreProcessing()\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n      clearStoreProcessing()\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n      that._storeProcessing = true\n\n      var packet = outStore.read(1)\n\n      var cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver()\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n        }\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\n        that._sendPacket(packet)\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    outStore.on('end', function () {\n      var allProcessed = true\n      for (var id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false\n          break\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing()\n        that.removeListener('close', remove)\n        that.emit('connect', packet)\n      } else {\n        startStreamProcess()\n      }\n    })\n    storeDeliver()\n  }\n  // start flowing\n  startStreamProcess()\n}\n\nmodule.exports = MqttClient\n"]},"metadata":{},"sourceType":"script"}