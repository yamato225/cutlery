{"ast":null,"code":"'use strict';\n\nvar Transform = require('readable-stream').Transform;\n\nvar duplexify = require('duplexify');\n\nvar WS = require('ws');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = WebSocketStream;\n\nfunction buildProxy(options, socketWrite, socketEnd) {\n  var proxy = new Transform({\n    objectMode: options.objectMode\n  });\n  proxy._write = socketWrite;\n  proxy._flush = socketEnd;\n  return proxy;\n}\n\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket;\n  var isBrowser = process.title === 'browser';\n  var isNative = !!global.WebSocket;\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols;\n    protocols = null;\n\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n\n  if (!options) options = {};\n\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined);\n  }\n\n  var proxy = buildProxy(options, socketWrite, socketEnd);\n\n  if (!options.objectMode) {\n    proxy._writev = writev;\n  } // browser only: sets the maximum socket buffer size before throttling\n\n\n  var bufferSize = options.browserBufferSize || 1024 * 512; // browser only: how long to wait when throttling\n\n  var bufferTimeout = options.browserBufferTimeout || 1000; // use existing WebSocket object that was passed in\n\n  if (typeof target === 'object') {\n    socket = target; // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols);\n    } else {\n      socket = new WS(target, protocols, options);\n    }\n\n    socket.binaryType = 'arraybuffer';\n  } // was already open when passed in\n\n\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy;\n  } else {\n    stream = stream = duplexify(undefined, undefined, options);\n\n    if (!options.objectMode) {\n      stream._writev = writev;\n    }\n\n    socket.onopen = onopen;\n  }\n\n  stream.socket = socket;\n  socket.onclose = onclose;\n  socket.onerror = onerror;\n  socket.onmessage = onmessage;\n  proxy.on('close', destroy);\n  var coerceToBuffer = !options.objectMode;\n\n  function socketWriteNode(chunk, enc, next) {\n    // avoid errors, this never happens unless\n    // destroy() is called\n    if (socket.readyState !== socket.OPEN) {\n      next();\n      return;\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8');\n    }\n\n    socket.send(chunk, next);\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n      return;\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8');\n    }\n\n    try {\n      socket.send(chunk);\n    } catch (err) {\n      return next(err);\n    }\n\n    next();\n  }\n\n  function socketEnd(done) {\n    socket.close();\n    done();\n  }\n\n  function onopen() {\n    stream.setReadable(proxy);\n    stream.setWritable(proxy);\n    stream.emit('connect');\n  }\n\n  function onclose() {\n    stream.end();\n    stream.destroy();\n  }\n\n  function onerror(err) {\n    stream.destroy(err);\n  }\n\n  function onmessage(event) {\n    var data = event.data;\n    if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n    proxy.push(data);\n  }\n\n  function destroy() {\n    socket.close();\n  } // this is to be enabled only if objectMode is false\n\n\n  function writev(chunks, cb) {\n    var buffers = new Array(chunks.length);\n\n    for (var i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8');\n      } else {\n        buffers[i] = chunks[i].chunk;\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb);\n  }\n\n  return stream;\n}","map":{"version":3,"sources":["/react/cutlery/web-console/node_modules/websocket-stream/stream.js"],"names":["Transform","require","duplexify","WS","Buffer","module","exports","WebSocketStream","buildProxy","options","socketWrite","socketEnd","proxy","objectMode","_write","_flush","target","protocols","stream","socket","isBrowser","process","title","isNative","global","WebSocket","socketWriteBrowser","socketWriteNode","Array","isArray","protocol","undefined","binary","_writev","writev","bufferSize","browserBufferSize","bufferTimeout","browserBufferTimeout","binaryType","readyState","OPEN","onopen","onclose","onerror","onmessage","on","destroy","coerceToBuffer","chunk","enc","next","from","send","bufferedAmount","setTimeout","err","done","close","setReadable","setWritable","emit","end","event","data","ArrayBuffer","push","chunks","cb","buffers","length","i","concat"],"mappings":"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","sourcesContent":["'use strict'\n\nvar Transform = require('readable-stream').Transform\nvar duplexify = require('duplexify')\nvar WS = require('ws')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = WebSocketStream\n\nfunction buildProxy (options, socketWrite, socketEnd) {\n  var proxy = new Transform({\n    objectMode: options.objectMode\n  })\n\n  proxy._write = socketWrite\n  proxy._flush = socketEnd\n\n  return proxy\n}\n\nfunction WebSocketStream(target, protocols, options) {\n  var stream, socket\n\n  var isBrowser = process.title === 'browser'\n  var isNative = !!global.WebSocket\n  var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode\n\n  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {\n    // accept the \"options\" Object as the 2nd argument\n    options = protocols\n    protocols = null\n\n    if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n      protocols = options.protocol;\n    }\n  }\n\n  if (!options) options = {}\n\n  if (options.objectMode === undefined) {\n    options.objectMode = !(options.binary === true || options.binary === undefined)\n  }\n\n  var proxy = buildProxy(options, socketWrite, socketEnd)\n\n  if (!options.objectMode) {\n    proxy._writev = writev\n  }\n\n  // browser only: sets the maximum socket buffer size before throttling\n  var bufferSize = options.browserBufferSize || 1024 * 512\n\n  // browser only: how long to wait when throttling\n  var bufferTimeout = options.browserBufferTimeout || 1000\n\n  // use existing WebSocket object that was passed in\n  if (typeof target === 'object') {\n    socket = target\n  // otherwise make a new one\n  } else {\n    // special constructor treatment for native websockets in browsers, see\n    // https://github.com/maxogden/websocket-stream/issues/82\n    if (isNative && isBrowser) {\n      socket = new WS(target, protocols)\n    } else {\n      socket = new WS(target, protocols, options)\n    }\n\n    socket.binaryType = 'arraybuffer'\n  }\n\n  // was already open when passed in\n  if (socket.readyState === socket.OPEN) {\n    stream = proxy\n  } else {\n    stream = stream = duplexify(undefined, undefined, options)\n    if (!options.objectMode) {\n      stream._writev = writev\n    }\n    socket.onopen = onopen\n  }\n\n  stream.socket = socket\n\n  socket.onclose = onclose\n  socket.onerror = onerror\n  socket.onmessage = onmessage\n\n  proxy.on('close', destroy)\n\n  var coerceToBuffer = !options.objectMode\n\n  function socketWriteNode(chunk, enc, next) {\n    // avoid errors, this never happens unless\n    // destroy() is called\n    if (socket.readyState !== socket.OPEN) {\n      next()\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n    socket.send(chunk, next)\n  }\n\n  function socketWriteBrowser(chunk, enc, next) {\n    if (socket.bufferedAmount > bufferSize) {\n      setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next)\n      return\n    }\n\n    if (coerceToBuffer && typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, 'utf8')\n    }\n\n    try {\n      socket.send(chunk)\n    } catch(err) {\n      return next(err)\n    }\n\n    next()\n  }\n\n  function socketEnd(done) {\n    socket.close()\n    done()\n  }\n\n  function onopen() {\n    stream.setReadable(proxy)\n    stream.setWritable(proxy)\n    stream.emit('connect')\n  }\n\n  function onclose() {\n    stream.end()\n    stream.destroy()\n  }\n\n  function onerror(err) {\n    stream.destroy(err)\n  }\n\n  function onmessage(event) {\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    else data = Buffer.from(data, 'utf8')\n    proxy.push(data)\n  }\n\n  function destroy() {\n    socket.close()\n  }\n\n  // this is to be enabled only if objectMode is false\n  function writev (chunks, cb) {\n    var buffers = new Array(chunks.length)\n    for (var i = 0; i < chunks.length; i++) {\n      if (typeof chunks[i].chunk === 'string') {\n        buffers[i] = Buffer.from(chunks[i], 'utf8')\n      } else {\n        buffers[i] = chunks[i].chunk\n      }\n    }\n\n    this._write(Buffer.concat(buffers), 'binary', cb)\n  }\n\n  return stream\n}\n"]},"metadata":{},"sourceType":"script"}