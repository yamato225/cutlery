{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar max = 65536;\nvar cache = {};\n\nfunction generateBuffer(i) {\n  var buffer = Buffer.allocUnsafe(2);\n  buffer.writeUInt8(i >> 8, 0);\n  buffer.writeUInt8(i & 0x00FF, 0 + 1);\n  return buffer;\n}\n\nfunction generateCache() {\n  for (var i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i);\n  }\n}\n/**\n * calcVariableByteIntLength - calculate the variable byte integer\n * length field\n *\n * @api private\n */\n\n\nfunction calcVariableByteIntLength(length) {\n  if (length >= 0 && length < 128) return 1;else if (length >= 128 && length < 16384) return 2;else if (length >= 16384 && length < 2097152) return 3;else if (length >= 2097152 && length < 268435456) return 4;else return 0;\n}\n\nfunction genBufVariableByteInt(num) {\n  var digit = 0;\n  var pos = 0;\n  var length = calcVariableByteIntLength(num);\n  var buffer = Buffer.allocUnsafe(length);\n\n  do {\n    digit = num % 128 | 0;\n    num = num / 128 | 0;\n    if (num > 0) digit = digit | 0x80;\n    buffer.writeUInt8(digit, pos++);\n  } while (num > 0);\n\n  return {\n    data: buffer,\n    length: length\n  };\n}\n\nfunction generate4ByteBuffer(num) {\n  var buffer = Buffer.allocUnsafe(4);\n  buffer.writeUInt32BE(num, 0);\n  return buffer;\n}\n\nmodule.exports = {\n  cache: cache,\n  generateCache: generateCache,\n  generateNumber: generateBuffer,\n  genBufVariableByteInt: genBufVariableByteInt,\n  generate4ByteBuffer: generate4ByteBuffer\n};","map":{"version":3,"sources":["/react/cutlery/web-console/node_modules/mqtt-packet/numbers.js"],"names":["Buffer","require","max","cache","generateBuffer","i","buffer","allocUnsafe","writeUInt8","generateCache","calcVariableByteIntLength","length","genBufVariableByteInt","num","digit","pos","data","generate4ByteBuffer","writeUInt32BE","module","exports","generateNumber"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAAP,CAAuBD,MAApC;;AACA,IAAIE,GAAG,GAAG,KAAV;AACA,IAAIC,KAAK,GAAG,EAAZ;;AAEA,SAASC,cAAT,CAAyBC,CAAzB,EAA4B;AAC1B,MAAIC,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmB,CAAnB,CAAb;AACAD,EAAAA,MAAM,CAACE,UAAP,CAAkBH,CAAC,IAAI,CAAvB,EAA0B,CAA1B;AACAC,EAAAA,MAAM,CAACE,UAAP,CAAkBH,CAAC,GAAG,MAAtB,EAA8B,IAAI,CAAlC;AAEA,SAAOC,MAAP;AACD;;AAED,SAASG,aAAT,GAA0B;AACxB,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAApB,EAAyBG,CAAC,EAA1B,EAA8B;AAC5BF,IAAAA,KAAK,CAACE,CAAD,CAAL,GAAWD,cAAc,CAACC,CAAD,CAAzB;AACD;AACF;AAED;;;;;;;;AAMA,SAASK,yBAAT,CAAoCC,MAApC,EAA4C;AAC1C,MAAIA,MAAM,IAAI,CAAV,IAAeA,MAAM,GAAG,GAA5B,EAAiC,OAAO,CAAP,CAAjC,KACK,IAAIA,MAAM,IAAI,GAAV,IAAiBA,MAAM,GAAG,KAA9B,EAAqC,OAAO,CAAP,CAArC,KACA,IAAIA,MAAM,IAAI,KAAV,IAAmBA,MAAM,GAAG,OAAhC,EAAyC,OAAO,CAAP,CAAzC,KACA,IAAIA,MAAM,IAAI,OAAV,IAAqBA,MAAM,GAAG,SAAlC,EAA6C,OAAO,CAAP,CAA7C,KACA,OAAO,CAAP;AACN;;AAED,SAASC,qBAAT,CAAgCC,GAAhC,EAAqC;AACnC,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIJ,MAAM,GAAGD,yBAAyB,CAACG,GAAD,CAAtC;AACA,MAAIP,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmBI,MAAnB,CAAb;;AAEA,KAAG;AACDG,IAAAA,KAAK,GAAGD,GAAG,GAAG,GAAN,GAAY,CAApB;AACAA,IAAAA,GAAG,GAAGA,GAAG,GAAG,GAAN,GAAY,CAAlB;AACA,QAAIA,GAAG,GAAG,CAAV,EAAaC,KAAK,GAAGA,KAAK,GAAG,IAAhB;AAEbR,IAAAA,MAAM,CAACE,UAAP,CAAkBM,KAAlB,EAAyBC,GAAG,EAA5B;AACD,GAND,QAMSF,GAAG,GAAG,CANf;;AAQA,SAAO;AACLG,IAAAA,IAAI,EAAEV,MADD;AAELK,IAAAA,MAAM,EAAEA;AAFH,GAAP;AAID;;AAED,SAASM,mBAAT,CAA8BJ,GAA9B,EAAmC;AACjC,MAAIP,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmB,CAAnB,CAAb;AACAD,EAAAA,MAAM,CAACY,aAAP,CAAqBL,GAArB,EAA0B,CAA1B;AACA,SAAOP,MAAP;AACD;;AAEDa,MAAM,CAACC,OAAP,GAAiB;AACfjB,EAAAA,KAAK,EAAEA,KADQ;AAEfM,EAAAA,aAAa,EAAEA,aAFA;AAGfY,EAAAA,cAAc,EAAEjB,cAHD;AAIfQ,EAAAA,qBAAqB,EAAEA,qBAJR;AAKfK,EAAAA,mBAAmB,EAAEA;AALN,CAAjB","sourcesContent":["'use strict'\n\nvar Buffer = require('safe-buffer').Buffer\nvar max = 65536\nvar cache = {}\n\nfunction generateBuffer (i) {\n  var buffer = Buffer.allocUnsafe(2)\n  buffer.writeUInt8(i >> 8, 0)\n  buffer.writeUInt8(i & 0x00FF, 0 + 1)\n\n  return buffer\n}\n\nfunction generateCache () {\n  for (var i = 0; i < max; i++) {\n    cache[i] = generateBuffer(i)\n  }\n}\n\n/**\n * calcVariableByteIntLength - calculate the variable byte integer\n * length field\n *\n * @api private\n */\nfunction calcVariableByteIntLength (length) {\n  if (length >= 0 && length < 128) return 1\n  else if (length >= 128 && length < 16384) return 2\n  else if (length >= 16384 && length < 2097152) return 3\n  else if (length >= 2097152 && length < 268435456) return 4\n  else return 0\n}\n\nfunction genBufVariableByteInt (num) {\n  var digit = 0\n  var pos = 0\n  var length = calcVariableByteIntLength(num)\n  var buffer = Buffer.allocUnsafe(length)\n\n  do {\n    digit = num % 128 | 0\n    num = num / 128 | 0\n    if (num > 0) digit = digit | 0x80\n\n    buffer.writeUInt8(digit, pos++)\n  } while (num > 0)\n\n  return {\n    data: buffer,\n    length: length\n  }\n}\n\nfunction generate4ByteBuffer (num) {\n  var buffer = Buffer.allocUnsafe(4)\n  buffer.writeUInt32BE(num, 0)\n  return buffer\n}\n\nmodule.exports = {\n  cache: cache,\n  generateCache: generateCache,\n  generateNumber: generateBuffer,\n  genBufVariableByteInt: genBufVariableByteInt,\n  generate4ByteBuffer: generate4ByteBuffer\n}\n"]},"metadata":{},"sourceType":"script"}